#pragma once
#include "HuffmanUtils.h"
#include <fstream>
#include <thread>
#include <bitset>

/*-----------------------------------------------------------------------------*/
/* Procedure declarations */

/* Reads a file and calculates the frequency of each character in that file */
void ReadFileData(std::string, std::unordered_map<char, int>&);

/*
	Reads a file and calculates the frequency of each character in that file.
	Returns a hashmap with character-to-frequency key-value pairs.
*/
std::unordered_map<char, int> ReadFileDataEx(const std::string);

/* Based on a dictionary, builds a Huffman Encoding Tree */
Node* ConstructHuffmanTree(std::unordered_map<char, int>&);

/* Based on a dictionary, builds a Huffman Tree with a vector as the underlying data structure */
Node* ConstructHuffmanTreeWithVector(std::unordered_map<char, int>&);

/* Encodes the Huffman Tree and returns a Hashmap with the encoded values */
std::unordered_map<char, std::string> Encode(Node*);

/*
	Encoder procedure (helper). Recursively encode each node until it
	reaches a leaf node. Encoding: left node = 0, right node = 1.
*/
void __encode(Node*, std::string, std::unordered_map<char, std::string>&);

/*
	Writes a dictionary to a file as char=char, where the first char
	is the char itself and the second char is the encoded char.
*/
void WriteSymbolTable(std::unordered_map<char, std::string>&, std::string);

/* Compresses a file using the Huffman compressing algorithm */
void CompressFile(std::unordered_map<char, std::string>&, std::string);

/*
	Adds a string of 0s and 1s to a byte buffer.
	Assumes that the string is of size 8.
*/
void AddStringToByteBuffer(std::string&, std::vector<unsigned char>&);

/*
	Encodes a file using the Huffman codes generated by a Huffman tree.
	The resulting file is a larger file but it's easier to decode.
*/
void EncodeFile(std::unordered_map<char, std::string>& HuffmanTable, std::string filename);